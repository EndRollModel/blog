<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>android - 動畫異常關閉錯誤</title>
    <link href="/blog/2024/07/04/android-%E5%8B%95%E7%95%AB%E7%95%B0%E5%B8%B8%E9%97%9C%E9%96%89%E9%8C%AF%E8%AA%A4/"/>
    <url>/blog/2024/07/04/android-%E5%8B%95%E7%95%AB%E7%95%B0%E5%B8%B8%E9%97%9C%E9%96%89%E9%8C%AF%E8%AA%A4/</url>
    
    <content type="html"><![CDATA[<p>起因：<br>使用者<font color="red">可能</font>進入了開發者人員選項<br>將動畫相關內容關閉<br>（有蠻多的手機加速緩解效能等文章都會要求關閉動畫避免增加資源消耗）<br>造成app動畫無法正常讀取卡死 被留了一星負評</p><p>主要原因：<br>若是使用Animator來實作自訂的內容則會受到該設定影響<br>維護的程式主要是因為該動畫播放結束前不會進行下一步的操作<br>故產生了卡死的現象</p><h4 id="處理方法："><a href="#處理方法：" class="headerlink" title="處理方法："></a>處理方法：</h4><p>解1（現實面）: 請使用者不要亂改開發者設定 </p><p>解2（程式面）: 因為開發者動畫設定屬於比較隱私的範圍 且並無公開api接口<br>所以必須採用映射的方式去修改該內容</p><p>android9以前可以映射ValueAnimator中的sDurationScale去修改值來達成效果<br>而sdk29以後 google將sDurationScale列為灰名單並且不讓開發者去讀取<br><a href="https://developer.android.google.cn/about/versions/10/non-sdk-q?hl=zh-cn">google說明</a></p><p>有一個@test函式setDurationScale內容是修改sDurationScale<br>映射該函式去修改sDurationScale來達到最後目的</p><p><a href="https://stackoverflow.com/questions/28516100/make-objectanimator-animation-duration-independent-of-global-animator-duration-s">stackoverflow</a></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Get duration scale from the global settings.</span><span class="hljs-type">float</span> <span class="hljs-variable">durationScale</span> <span class="hljs-operator">=</span> Settings.Global.getFloat(context.getContentResolver(),                        Settings.Global.ANIMATOR_DURATION_SCALE, <span class="hljs-number">0</span>);<span class="hljs-comment">// If global duration scale is not 1 (default), try to override it</span><span class="hljs-comment">// for the current application.</span><span class="hljs-keyword">if</span> (durationScale != <span class="hljs-number">1</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    ValueAnimator.class.getMethod(<span class="hljs-string">&quot;setDurationScale&quot;</span>, <span class="hljs-type">float</span>.class).invoke(<span class="hljs-literal">null</span>, <span class="hljs-number">1f</span>);    durationScale = <span class="hljs-number">1f</span>;  &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;    <span class="hljs-comment">// It means something bad happened, and animations are still</span>    <span class="hljs-comment">// altered by the global settings. You should warn the user and</span>    <span class="hljs-comment">// exit application.</span>  &#125;&#125;</code></pre></div><p>該方法放在onCreate或是需要讀取動畫的地方即可</p><p>＊補充＊<br>防使用者去做這種事情真的很累<br>開發者設定警告本就有 如果亂改可能會造成無法正常執行的錯誤<br>完全都不會知道你親愛的使用者都對他的手機做了什麼<br>結果你不知道發生了什麼 然後就被留了一星或是負面評價<br>開發者們 真的是辛苦了 O7</p>]]></content>
    
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo - 幫Fluid加上CC0著作</title>
    <link href="/blog/2024/06/20/Hexo-%E5%B9%ABFluid%E5%8A%A0%E4%B8%8ACC0%E8%91%97%E4%BD%9C/"/>
    <url>/blog/2024/06/20/Hexo-%E5%B9%ABFluid%E5%8A%A0%E4%B8%8ACC0%E8%91%97%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>目前因為 Fluid 主題尚未增加 <a href="https://creativecommons.org/publicdomain/zero/1.0/deed.zh-hant">CC0 1.0</a> 的標註</p><p>但在Fluid的<a href="https://github.com/fluid-dev/hexo-theme-fluid/issues/1053">[issue&#x2F;1053]</a>有提出該問題 但目前還未新增CC0相關的內容</p><p>原本是想說無著作權則不標註作者欄位與著作權宣告</p><p>但這個宣告模組太漂亮了 我想把它擺在下面展示 XD</p><p>最後只好手動新增並且做個紀錄了</p><p>修改以下內容</p><ol><li>修改檔案</li></ol><ul><li>檔案路徑 : <code>theme/fluid/languages/zh-TW.yml</code><br>copyright 中新增一行<br><code>CC0: &#39;CC0 - 無著作權&#39;</code></li></ul><ol start="2"><li>修改檔案</li></ol><ul><li>檔案路徑 : <code>theme/fluid/layout/_partails/post/copyright</code><br>  行數：50  <div class="code-wrapper"><pre><code class="hljs ejs">&lt;%- license %&gt;</code></pre></div>  替換成以下內容  <div class="code-wrapper"><pre><code class="hljs ejs">&lt;% if (license.toUpperCase() === &#x27;CC0&#x27;) &#123; %&gt;    &lt;a class=&quot;print-no-link&quot; target=&quot;_blank&quot; href=&quot;https://creativecommons.org/public-domain/cc0/&quot;&gt;       &lt;span class=&quot;hint--right hint--rounded&quot; aria-label=&quot;&lt;%- __(&#x27;post.copyright.CC0&#x27;) %&gt;&quot;&gt;           &lt;img class=&quot;iconfont icon-cc-zero&quot; style=&quot;width: 16px; height: 16px;&quot; src=&quot;&lt;%= config.root%&gt;img/cc-zero.svg&quot; alt=&quot;&quot;/&gt;       &lt;/span&gt;    &lt;/a&gt;&lt;% &#125; else &#123; %&gt;    &lt;%- license %&gt;&lt;% &#125; %&gt;</code></pre></div></li></ul><ol start="3"><li><p>使用該<a href="https://chooser-beta.creativecommons.org/">選擇器</a>選擇CC0的版權 存下該圖 將圖放入<code>/Img</code>並將檔名命名為<code>cc-zero.svg</code></p></li><li><p>修改<code>_config.fluid.yml</code>中的<code>copyright / license</code>值為CC0就可以使用了</p></li></ol><p>–<br>2024.6.24 更新<br>後續看Fluid的dev分支時發現作者其實已經有將<a href="https://github.com/fluid-dev/hexo-theme-fluid/commit/781fd8e55947ffa838fda4af21632d45f59582ae">內容</a>更新上去了<br>但還是沒有版到正式之中 本文僅做紀錄與先套用該方案的內容 實際待版本更新後可更新至新版</p><p>參考資料與相關閱讀</p><ul><li><a href="https://zh.wikipedia.org/zh-tw/%E5%85%AC%E6%9C%89%E9%A2%86%E5%9F%9F">公眾領域&#x2F;公有領域wiki</a> </li><li><a href="https://creativecommons.org/share-your-work/cclicenses/">ABOUT CC LICENSES</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js - Firebase storage 上傳圖片</title>
    <link href="/blog/2024/04/24/firebase-storage-upload/"/>
    <url>/blog/2024/04/24/firebase-storage-upload/</url>
    
    <content type="html"><![CDATA[<h1 id="Firebase-Storage上傳"><a href="#Firebase-Storage上傳" class="headerlink" title="Firebase Storage上傳"></a>Firebase Storage上傳</h1><h3 id="說明："><a href="#說明：" class="headerlink" title="說明："></a>說明：</h3><p>由於想使用google app script上傳圖片<br>但是app script本身不支援firebase admin相關的套件</p><p>以前曾經使用google cloud storage的bucket轉至firebase後<br>另外申請下載用的網址才能運作<br>但實在年代久遠忘記怎麼做了 該份原始碼也丟失了</p><p>最終原本也是要使用google cloud storage上傳後再處理<br>發現firebase也可以使用post上傳圖片<br>只要驗證使用者就可以通過安全性規則</p><h3 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h3><p>建立匿名使用者後 使用該使用者通過安全性規則 再讓該使用者上傳圖片</p><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ol><li><p><a href="https://console.firebase.google.com/u/0/">建立Firebase專案</a></p></li><li><p>開啟專案設定 ⮕ 一般設定標籤 ⮕ 紀錄 <strong>“網路 API 金鑰(web api key)”</strong></p></li><li><p>專案設定 ⮕ 服務帳戶標籤 ⮕ Firebase Admin功能中 產生新的私密金鑰 ⮕ <strong>下載金鑰</strong></p></li><li><p>使用以下程式碼建立JWT <a href="https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=zh-tw">官方Jwt說明</a></p></li><li><p>使用以下程式碼建立匿名使用者並取得UserToken <a href="https://firebase.google.com/docs/reference/rest/auth?hl=zh-tw">官方Restful說明</a></p></li><li><p>使用以下程式碼上傳圖片 <a href="https://stackoverflow.com/questions/46806545/how-to-upload-objects-to-firebase-storage-using-postman-for-testing">stackoverflow問題(官方來源找不到)</a></p></li></ol><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 建立jwt的機制</span><span class="hljs-comment"> * 認證的樣式 依照官方文件建立</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">createJWT</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 這裡使用的內容 請參考步驟3取得的金鑰內容</span>  <span class="hljs-keyword">const</span> privatKey = <span class="hljs-string">&#x27;your private_key&#x27;</span>;  <span class="hljs-keyword">const</span> clientEmail = <span class="hljs-string">&#x27;your client_email&#x27;</span>;  <span class="hljs-keyword">const</span> userId = <span class="hljs-string">&#x27;your user id&#x27;</span>; <span class="hljs-comment">// 可自訂uid的內容 id會顯示在 firebase auth之中</span>      <span class="hljs-keyword">const</span> header = &#123;    <span class="hljs-attr">alg</span>: <span class="hljs-string">&#x27;RS256&#x27;</span>,    <span class="hljs-attr">typ</span>: <span class="hljs-string">&#x27;JWT&#x27;</span>,  &#125;;  <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();  <span class="hljs-keyword">const</span> expires = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(now);  expires.<span class="hljs-title function_">setHours</span>(expires.<span class="hljs-title function_">getHours</span>() + <span class="hljs-number">1</span>); <span class="hljs-comment">// 一小時過期</span>  <span class="hljs-keyword">const</span> payload = &#123;    <span class="hljs-attr">iss</span>: clientEmail,    <span class="hljs-attr">sub</span>: clientEmail,    <span class="hljs-attr">aud</span>: <span class="hljs-string">&#x27;https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit&#x27;</span>,    <span class="hljs-attr">iat</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(now / <span class="hljs-number">1000</span>),    <span class="hljs-attr">exp</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(expires.<span class="hljs-title function_">getTime</span>() / <span class="hljs-number">1000</span>),    <span class="hljs-attr">uid</span>: userId, <span class="hljs-comment">// </span>  &#125;;  <span class="hljs-keyword">let</span> toSign = <span class="hljs-title class_">Utilities</span>.<span class="hljs-title function_">base64Encode</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(header)) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-title class_">Utilities</span>.<span class="hljs-title function_">base64Encode</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload));  <span class="hljs-keyword">let</span> key = privatKey.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\n/g</span>, <span class="hljs-string">&#x27;\n&#x27;</span>); <span class="hljs-comment">// key因為放在系統參數中才需使用 否則不用該行</span>  <span class="hljs-keyword">const</span> signatureBytes = <span class="hljs-title class_">Utilities</span>.<span class="hljs-title function_">computeRsaSha256Signature</span>(    toSign,    key  );  <span class="hljs-keyword">const</span> signature = <span class="hljs-title class_">Utilities</span>.<span class="hljs-title function_">base64Encode</span>(signatureBytes);  <span class="hljs-keyword">return</span> toSign + <span class="hljs-string">&#x27;.&#x27;</span> + signature;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 取得使用者的token </span><span class="hljs-comment"> * 來源：https://firebase.google.com/docs/reference/rest/auth?hl=zh-tw</span><span class="hljs-comment"> * */</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserToken</span>(<span class="hljs-params">jwtToken</span>)&#123;  <span class="hljs-keyword">const</span> projectApiKey = <span class="hljs-string">&quot;web api key&quot;</span>; <span class="hljs-comment">// 步驟2中取得的web api key</span>  <span class="hljs-keyword">const</span> baseUrl = <span class="hljs-string">`https://identitytoolkit.googleapis.com/v1/accounts:signInWithCustomToken?key=<span class="hljs-subst">$&#123;projectApiKey&#125;</span>`</span>  <span class="hljs-keyword">const</span> requestBody = &#123;    <span class="hljs-string">&quot;token&quot;</span>: jwtToken,    <span class="hljs-string">&quot;returnSecureToken&quot;</span>: <span class="hljs-literal">true</span>  &#125;;  <span class="hljs-keyword">const</span> options = &#123;    <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;post&quot;</span>,    <span class="hljs-string">&quot;contentType&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,    <span class="hljs-string">&quot;payload&quot;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestBody),  &#125;;  <span class="hljs-keyword">const</span> response = <span class="hljs-title class_">UrlFetchApp</span>.<span class="hljs-title function_">fetch</span>(baseUrl, options);  <span class="hljs-comment">// 處理回應</span>  <span class="hljs-keyword">const</span> responseData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-title function_">getContentText</span>());  <span class="hljs-keyword">return</span> responseData.<span class="hljs-property">idToken</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> uploadImage = <span class="hljs-function">(<span class="hljs-params">fileName, image</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> uploadUserToken = <span class="hljs-title function_">getUserToken</span>();  <span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">const</span> baseUrl = <span class="hljs-string">`https://firebasestorage.googleapis.com/v0/b/<span class="hljs-subst">$&#123;bucketName&#125;</span>/o/<span class="hljs-subst">$&#123;fileName&#125;</span>`</span>    <span class="hljs-keyword">const</span> options = &#123;        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,        <span class="hljs-attr">headers</span>: &#123;            <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;uploadUserToken&#125;</span>`</span>,            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/octet-stream&#x27;</span>,        &#125;,        payload : image,    &#125;;    <span class="hljs-keyword">const</span> response = <span class="hljs-title class_">UrlFetchApp</span>.<span class="hljs-title function_">fetch</span>(baseUrl, options);    <span class="hljs-keyword">const</span> responseData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-title function_">getContentText</span>());    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(responseData, <span class="hljs-string">&#x27;bucket&#x27;</span>)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> imageUrl = <span class="hljs-string">`https://firebasestorage.googleapis.com/v0/b/<span class="hljs-subst">$&#123;responseData.bucket&#125;</span>/o/<span class="hljs-subst">$&#123;responseData.name&#125;</span>?alt=media&amp;token=<span class="hljs-subst">$&#123;responseData.downloadTokens&#125;</span>`</span>;        <span class="hljs-keyword">return</span> imageUrl    &#125;  &#125;<span class="hljs-keyword">catch</span>(e)&#123;    <span class="hljs-keyword">return</span> e.<span class="hljs-property">message</span>;  &#125;&#125;</code></pre></div><h3 id="Firebase-安全性規則"><a href="#Firebase-安全性規則" class="headerlink" title="Firebase 安全性規則"></a>Firebase 安全性規則</h3><p>寫入：必須為登入者 3mb以下 並且限定圖片<br>讀：必須為登入者要求</p><div class="code-wrapper"><pre><code class="hljs roboconf">service firebase.storage &#123;  <span class="hljs-attribute">match /b/&#123;bucket&#125;/o &#123;</span><span class="hljs-attribute">    match /&#123;allPaths=**&#125; &#123;</span><span class="hljs-attribute">    allow write</span>: if request<span class="hljs-variable">.auth</span> != null        &amp;&amp; request<span class="hljs-variable">.resource</span><span class="hljs-variable">.size</span> &lt; 3 * 1024 * 1024                  &amp;&amp; request<span class="hljs-variable">.resource</span><span class="hljs-variable">.contentType</span><span class="hljs-variable">.matches</span>(&#x27;image/.*&#x27;);      <span class="hljs-attribute">allow read</span>: if request<span class="hljs-variable">.auth</span> != null;    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>google app script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js - Regex 篩選中文字</title>
    <link href="/blog/2022/10/04/js-regex-cjk/"/>
    <url>/blog/2022/10/04/js-regex-cjk/</url>
    
    <content type="html"><![CDATA[<p>需要篩選中文的正則處理<br>網路上查到的內容幾乎都是        </p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\u4e00-\u9fa5/</span></code></pre></div><p>雖然能處理大多的中文<br>但是目前有個case就是中文有些<strong>難字</strong><br>少用但是偶爾會出現的狀況 無法被上述程式所篩選     </p><p>查詢過後發現難字等內容皆為<br>中日韓統合表意文字擴充(CJK Unified Ideographs Extension)<sup><a href="#%E5%8F%83%E8%80%83%E4%BE%86%E6%BA%90%E5%85%A7%E5%AE%B9">1</a></sup>的部分<br>難字與後續新增的擴充字型皆列於此內 且持續新增中<br>現(22&#x2F;09)已經擴充到H包 所以需要對上述之程式做擴充<br>此內容<sup><a href="#%E5%8F%83%E8%80%83%E4%BE%86%E6%BA%90%E5%85%A7%E5%AE%B9">2</a></sup>提供可支援至D包的寫法        </p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 此處內容僅供參考 若需使用請先測試可行後才使用</span><span class="hljs-comment">// D包後的擴充內容（含）須自行抓取編號轉換後寫入 （轉換方法於補充有說明）</span><span class="hljs-comment">// 擴充B包 對應 20000-2A6D6</span><span class="hljs-keyword">const</span> extendCJK_B = <span class="hljs-regexp">/[\ud840-\ud868][\udc00-\udfff]|\ud869[\udc00-\uded6]/</span>        <span class="hljs-comment">// 擴充C包 對應 2A700-2B734</span><span class="hljs-keyword">const</span> extendCJK_C = <span class="hljs-regexp">/\ud869[\udf00-\udfff]|[\ud86a-\ud86c][\udc00-\udfff]|\ud86d[\udc00-\udf34]/</span><span class="hljs-comment">// 擴充D包 對應 2B840-2B81D </span><span class="hljs-keyword">const</span> extendCJK_D = <span class="hljs-regexp">/\ud86d[\udf40-\udfff]|\ud86e[\udc00-\udc1d]/</span><span class="hljs-comment">// 兼容表意文字12字 對應 F900-FA6D/FA70-FAD9</span><span class="hljs-keyword">const</span> extendCJK_Ideo = <span class="hljs-regexp">/[\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA1F\uFA21\uFA23\uFA24\uFA27-\uFA29]/</span> <span class="hljs-comment">// 上述內容組合 文字至D包擴充</span><span class="hljs-keyword">const</span> extendCJK_toD = <span class="hljs-regexp">/[\u4E00-\u9FCC\u3400-\u4DB5\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA1F\uFA21\uFA23\uFA24\uFA27-\uFA29]|[\ud840-\ud868][\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|[\ud86a-\ud86c][\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d]/</span></code></pre></div><p>如上所示 若有新增語言包內容則需一直新增下去<br>最後查詢由Unicode所提供的方法為<br>使用Regex後面新增的&#x2F;u標籤去處理unicode      </p><p>另外 若無特殊需求 僅抓取中文字的話 使用下述之方法即可</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 抓取所有中文內容(不用自己擴充)</span><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\p&#123;Ideographic&#125;/u</span></code></pre></div><p>…查了老半天結果短短一行可以解決</p><p>若需要自己指定擴充包或是字碼內容 需使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint">String.fromCodePoint()</a>處理然後加入該內容<br>ex:<code>String.fromCodePoint(0x2F804);  // &quot;\uD87E\uDC04&quot;</code></p><p>注意事項:<br>此方法還會抓取日韓相關的字元，使用前也要確定符合使用的情境<br>另瀏覽器必須是Chrome 64、Firefox 78、Safari 11.1 和 Edge 79 以上才支援&#x2F;u的語法使用     </p><hr><h4 id="參考來源內容"><a href="#參考來源內容" class="headerlink" title="參考來源內容"></a>參考來源內容</h4><p><a href="https://www.unicode.org/reports/tr38/#BlockListing">1. unicode(CJK支援範圍內容)</a><br><a href="https://stackoverflow.com/questions/21109011/javascript-unicode-string-chinese-character-but-no-punctuation">2. stackoverflow(Javascript unicode string, chinese character but no punctuation)</a>        </p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js - 偵測網頁關閉事件</title>
    <link href="/blog/2022/09/08/js-close-listener/"/>
    <url>/blog/2022/09/08/js-close-listener/</url>
    
    <content type="html"><![CDATA[<p>事件的起因是這樣的<br>客戶提出了需求要有關閉網頁後登出的功能,並且提出了其他家的實際製作成品方案。</p><p>其他家的狀況是有Ａ至Ｂ時（開啟新分頁） Ｂ網頁關閉後登出 或是在Ｂ頁面上登出按鈕按下後登出 </p><p><strong>老闆曰：「為什麼對方可以 我們不行」 <del>因為架構不同</del></strong><br>所以開始了一段奇幻的撞牆紀錄</p><p>稍微研究後紀錄了以下內容</p><h3 id="對方的做法"><a href="#對方的做法" class="headerlink" title="對方的做法"></a>對方的做法</h3><p>對方進入頁面時採用了SSO進行登入動作<br>於離開網頁的時候 使用了beforeunload或unload去抓取事件<br>beforeunload : 頁面準備銷毀之前會觸發 抓取事件(上下頁 重整 瀏覽分頁關閉 瀏覽器關閉)<br>並且對方機制是採用了類似location.replace()的機制(即取代當前的頁面而不是跳轉 不會留下histroy 或是 直接更新頁面上的資料)<br>因此瀏覽器的上下頁按鈕不會亮起 並且<a href="https://stackoverflow.com/questions/2482059/disable-f5-and-browser-refresh-using-javascript">鎖住了f5的功能</a><br>(但是如果按下重新整理按鈕會被登出 因瀏覽器本身禁止開發者禁止上面的按鈕被封鎖)</p><h3 id="我們的做法"><a href="#我們的做法" class="headerlink" title="我們的做法"></a>我們的做法</h3><p>我們是一般的登入系統<br>由於我對ASP.NET不熟 想法是將js寫入至master page（每個頁面都會載入的page）內<br><strong>「理論上並不會影響到該邏輯並且應該能正常運作」</strong><br>但套入master後的任何功能 包含登入由於都是callback 頁面皆會銷毀（並且載入新的cs邏輯後的頁面) 最後造成js抓取事件 任何一動都會觸發beforeunload</p><h4 id="到這裡-我看起來像是有辦法嗎¯-ツ-¯"><a href="#到這裡-我看起來像是有辦法嗎¯-ツ-¯" class="headerlink" title="到這裡 我看起來像是有辦法嗎¯\_(ツ)_&#x2F;¯"></a>到這裡 我看起來像是有辦法嗎¯\_(ツ)_&#x2F;¯</h4><p>最後也是將基本的 beforeunload + <a href="https://developer.mozilla.org/en-US/docs/Web/API/Beacon_API">beacon</a> 的寫法紀錄上交 不能算是有解</p><div class="code-wrapper"><pre><code class="hljs">作法 : 觸發beforeunload時 將beacon訊息送出 告知後端該使用者已觸發beforeunload再看傳輸出去的內容與動作來決定後端該怎麼處理個人認為：最好的方式還是使用session過期或是cookie之類的計算時間後再將使用者登出會比較合理</code></pre></div><p>但如果真要改 可能要從架構或是看ASP有沒有省略或是使用cookie去做開關的機制<br>想法：「跳轉或是銷毀前需做cookie紀錄 並且於下次載入的js內檢查cookie是否帶著跳轉用的開關後重置該cookie內容」</p><h3 id="另外一些關於關閉的事件紀錄"><a href="#另外一些關於關閉的事件紀錄" class="headerlink" title="另外一些關於關閉的事件紀錄"></a>另外一些關於關閉的事件紀錄</h3><p>在以下的測試中紀錄beforeunload與unload的使用狀況<br>以及一些其他的關於瀏覽器關閉的相關紀錄</p><h4 id="beforeunload"><a href="#beforeunload" class="headerlink" title="beforeunload:"></a>beforeunload:</h4><p>該引用JS的視窗銷毀之前的事件大部分情形會抓到(少數抓不到 原因不一)<br>需要注意如果是使用windows open的話<br>父視窗會抓不到子視窗open的事件(即使將windows.open設為物件 仍無法抓取該內容的事件監聽) 需在子視窗抓取該beforeunload事件 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage</a> 回父視窗做傳輸<br>告知父視窗該子視窗已經被關閉<br>（作為子視窗被關閉時beforeunload事件大部分都是有效的）</p><h4 id="unload"><a href="#unload" class="headerlink" title="unload:"></a>unload:</h4><p>該引用JS的視窗銷毀時會抓到的事件 經常會有抓不到的情形(由於頁面已經被銷毀 有時該event來不及被處理) MDN上已警告開發者盡量避免使用該api去抓取事件<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event">來源:MDN</a></p><p>該MDN頁面上也有提供另外關於網頁生命週期的方式去偵測網頁狀態<br>並且使用了google的<a href="https://github.com/GoogleChromeLabs/page-lifecycle">page-lifecycle</a></p><p>但使用page-lifecycle(2022&#x2F;09)關閉tab的事件時 edge與chrome的銷毀生命週期並不相同<br>另外edge因sleep事件 放置分頁至睡眠時可能會觸發frozen<br>並且由於asp放在master內也會造成任何一動皆銷毀頁面 所以生命週期方法也不行</p><p>2015提出了生命週期的問題後 到2023還是沒有辦法更好的抓取生命週期<br>外加各家瀏覽器的實裝內容不同 終究無法好好的整理生命週期統一<br><a href="https://www.igvita.com/2015/11/20/dont-lose-user-and-app-state-use-page-visibility/">來源說明: 2015提出生命週期</a></p><p>但生命週期的處理可以比較好的適用於移動端的瀏覽器<br>桌面版瀏覽器的話還是使用beforeunload與unload<br>有可能會需要再JS內做裝置判斷 然後決定套用哪種生命週期去做事情</p><p>並且這涉及架構問題 若新寫的網頁還可以考慮使用以上部分方法去設計<br>若是已成形的網站需要改成以上架構就會需要動到很多的部分 屬實不容易</p><hr><p>＊補充：若是可用其他技術補助的話 使用Socket也是可以解決此問題<br>一但disconnect後 就當作已登出處理 僅抓事件判定有太多的不穩定性</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
